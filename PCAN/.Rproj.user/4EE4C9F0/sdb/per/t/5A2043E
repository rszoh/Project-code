{
    "contents" : "#### Update parameters functions\n### Define all the inputs values\n### A:matrix of p * d, B: matrix of q*d, tau = vector of length d\n### mute:vector of length p, mulb: vector of length q\n### tet: matrix of n*p and lamb: matrix of n*q\n### sigte: vector of length p, siglb: vector of length q\n###\nlibrary(dlm)\ntauj <-function(al0,bet0,A,B,j) ### j: the column of A\n{\n#J <-ncol(A)\n#val <-numeric(J)\n#for(j in 1:J)\n#{\nmaj <- sum( (1:nrow(A)) > j)\nmbj <- sum( (1:nrow(B)) > j)\naln <-.5*(maj+mbj) + al0\nbetn <- (1/bet0) + .5*(sum(A[,j]^2) + sum(B[,j]^2))\nval <-rgamma(n=1,shape=aln,scale=1/betn)\n#}\nreturn(val)  \n}\napply(matrix(1:ncol(A),ncol=1),1,tauj,al0=al0,bet0=bet0,A=A,B=B)\n\n\nsigtej <-function(nu0,S0,A,Z,tet,mute,j) ## tet is a n*p matrix ,Z is a d*n matrix\n{\np <-ncol(tet)\nn <- nrow(tet)\n#val <-numeric(p)\n#for(j in 1:p)\n#{\nscl <- (nu0*S0 + sum((tet[,j] - t(Z)%*%matrix(A[j,],ncol=1) - mute[j])^2))\nval <- scl / rchisq(n=1,df=n+nu0) \n#}\nreturn(val)\n}\napply(matrix(1:ncol(tet),ncol=1),1,sigtej,nu0=nu0,S0=S0,A=A,Z=Z,tet=tet,mute=mute)\n\nsiglbj <-function(nu0,S0,B,Z,lamb,mulb,j) ## lamb is a n*q matrix ,Z is a d*n matrix\n{\n  n <- nrow(lamb)\n  q <- ncol(lamb)\n  val <-numeric(q)\n  #for(j in 1:q)\n  #{\n  scl <- (nu0*S0 + sum( (lamb[,j] - t(Z)%*%matrix(B[j,],ncol=1)- mulb[j])^2))\n  val <- scl / rchisq(n=1,df=n+nu0)\n  #}\n  return(val)\n}\napply(matrix(1:ncol(lamb),ncol=1),1,siglbj,nu0=nu0,S0=S0,B=B,Z=Z,lamb=lamb,mulb=mulb)\n\nmutej <-function(sigte,sigte0,A,Z,tet,j) ## j=1, ...,p\n{\nn=nrow(tet)\np<-ncol(tet)\nval <-numeric(p)\n#for(j in 1:p)\n#{\nsig <- ((n/sigte[j]) + (1/sigte0))^(-1)\nmn <- (1/sigte[j])*sig*sum(tet[,j] - t(Z)%*%matrix(A[j,],ncol=1))\nval <-rnorm(n=1,mean=mn,sd=sqrt(sig))\n#}\nreturn(val)\n}\napply(matrix(1:ncol(tet),ncol=1),1,mutej,sigte=sigte,sigte0=sigte0,A=A,Z=Z,tet=tet)\n\n mulbl <-function(siglb,siglb0,B,Z,lamb,l) ## l=1, ... ,q\n{\n  n=nrow(lamb)\n  q <- ncol(lamb)\n  val <-numeric(q)\n  #for(l in 1:q)\n  #{\n  sig <- ((n/siglb[l]) + (1/siglb0))^(-1)\n  mn <- (1/siglb[l])*sig*sum(lamb[,l] - t(Z)%*%matrix(B[l,],ncol=1))\n  val<-rnorm(n=1,mean=mn,sd=sqrt(sig))\n  #}\n  return(val)\n}\napply(matrix(1:ncol(lamb),ncol=1),1,mulbl,siglb=siglb,siglb0=siglb0,B=B,Z=Z,lamb=lamb)\n\najl <-function(sigte,mute,A,Z,tet,tau,id) ##j=1,...,p and l=1,...,d; Z is d*n matrix; id (j,l) vector\n{\nj=id[1]\nl=id[2]\nsig <- ((1/sigte[j])*sum(Z[l,]^2) + tau[l])^{-1}   \nmun <- (1/sigte[j])*sig*sum(tet[,j] - mute[j] - t(Z[-l,]%*%matrix(A[j,-l],ncol=1)))\nif(j > l)\n{val <-rnorm(n=1,mean=mun,sd=sqrt(sig))}\nelse if(j ==l)\n{val <- rtruncnorm(n=1,a=0,mean=mun,sd=sqrt(sig))}\nelse \n{val <- 0}\nreturn(val)\n}\najl(sigte,mute,A,Z,tet,tau,c(2,1))\nida <- matrix(cbind(rep(1:nrow(A),each=ncol(A)), rep(c(1:ncol(A)),nrow(A))),ncol=2)\nmatrix(apply(ida,1,ajl,sigte=sigte,mute=mute,A=A,Z=Z,tet=tet,tau=tau),ncol=ncol(A),byrow=T)\n\n############################\nbkl <-function(siglb,mulb,B,Z,lamb,tau,id) ##k=1,...,p and l=1,...,d; Z is d*n matrix\n{\n  k<-id[1]\n  l<-id[2]\n  sig <- ((1/siglb[k])*sum(Z[l,]^2) + tau[l])^{-1}   \n  mun <-(1/siglb[k])*sig*sum(lamb[,k] - mulb[k] - t(Z[-l,]%*%matrix(B[k,-l],ncol=1)))\nif(k > l)\n  {val <-rnorm(n=1,mean=mun,sd=sqrt(sig))}\nelse if(k==l)\n{val <- rtruncnorm(n=1,a=0,mean=mun,sd=sqrt(sig))}\n  else { val <- 0 }\nreturn(val)\n}\n\n### \nZi <-function(sigte,siglb,tet,lamb,A,B,mute,mulb,i)\n{\nsig = solve(diag(rep(1,ncol(A))) + t(A)%*%diag(1/sigte)%*%A + t(B)%*%diag(1/siglb)%*%B)\nmn<-NULL\n#for(i in 1:nrow(tet))\nmn =as.vector((t(matrix(tet[i,] - mute,ncol=1))%*%diag(1/sigte)%*%A + t(matrix(lamb[i,] - mulb,ncol=1))%*%diag(1/siglb)%*%B)%*%sig)\nval <- rmvnorm(n=1,mean=mn,sigma=sig)\nreturn(val)\n#return(rmvnorm(n=1,mean=as.vector(mn),sigma=sig))  \n}\n\n\n####\n### likelihood function \n\nlikhd<-function(tet,Z,X,sig,A,mu) # Z(d*1) vector; tet(p*1) vector; X(p*1) vector, sig(p*1)vector; A(p*d),mu(p*1)\n{\n  #gam_m<-diag(gam,nrow=length(gam))\n  sigm <- diag(sig)\n  res=-(1/2)*t(tet - (A%*%matrix(Z,ncol=1) + mu + X*sig))%*%diag(1/sig)%*%(tet - (A%*%Z + mu + X*sig)) - sum(exp(tet)) ### like lihood minus the exp(-exp(tet)) term\n  return(res)  \n}\n#### rejection ratio\n########################################################################################################\n## this function uses the arsm\n#stop(\"Lets see what we got! \\n \" )\nadap_rej<-function(An,Xn,Zn,sig_n,mu)\n{\n  ot=matrix(0,ncol=nrow(An),nrow=nrow(Xn))\n  for(j in 1:nrow(Xn))   \n  {\n    ot[j,] <- arms(runif(nrow(An),-30,30),likhd,function(tet,...) (min(tet) >-30)*(max(tet)<30),n, Z=Zn[,j],A=An,sig=sig_n,X=Xn[j,],mu=mu)[1,] \n  }   \n  return(ot)\n}\n\n\n\n\n",
    "created" : 1390022538855.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "9|1|21|0|\n26|1|36|0|\n40|1|50|0|\n54|1|65|0|\n69|1|80|0|\n103|1|114|0|\n118|1|126|0|\n144|1|151|0|\n",
    "hash" : "1361411743",
    "id" : "5A2043E",
    "lastKnownWriteTime" : 1390255169,
    "path" : "~/Desktop/PCAN/update_functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}